package se.lu.nateko.cp.cpauth.accounts

import java.sql.Connection

import java.security.MessageDigest
import java.util.Base64

import scala.collection.mutable.Buffer
import scala.concurrent.Await
import scala.concurrent.ExecutionContext
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt

import se.lu.nateko.cp.cpauth.core.UserId
import se.lu.nateko.cp.cpauth.core.AuthenticationFailedException
import se.lu.nateko.cp.cpauth.core.cpauthException


trait UsersIo{
	def addUser(userEntry: UserEntry, password: String): Future[Unit]
	def userExists(uid: UserId): Future[Boolean]
	def authenticateUser(uid: UserId, password: String): Future[UserEntry]
	def dropUser(uid: UserId): Future[Unit]
	def updateUser(oldUid: UserId, userEntry: UserEntry, newPass: String): Future[Unit]
	def listUsers: Future[Seq[UserEntry]]
	def userIsAdmin(uid: UserId): Future[Boolean]
	def setAdminRights(uid: UserId, isAdmin: Boolean): Future[Unit]
	def init(): Future[Unit]
}


class JdbcUsers(getConnection: () => Connection)(using ExecutionContext) extends UsersIo:

	private def execute(statement: String): Future[Unit] = withConnection{ conn =>
		val st = conn.createStatement
		st.execute(statement)
		st.close()
	}

	private def withConnection[T](work: Connection => T): Future[T] = Future{
		val conn = getConnection()
		try{
			work(conn)
		} finally{
			conn.close()
		}
	}

	def hash(mail: String, pass: String): String = {
		val md = MessageDigest.getInstance("MD5")
		md.update(mail.getBytes("UTF-8"))
		val salt: Array[Byte] = md.digest
		val hmd = MessageDigest.getInstance("SHA-256")
		hmd.update( salt ++ pass.getBytes("UTF-8"))
		val hashBytes = hmd.digest
		Base64.getEncoder.encodeToString(hashBytes)
	}

	def init(): Future[Unit] = {
		val sql = """create table if not exists users (
			user_id	   integer generated by default as identity(start with 1) not null,
			mail	   varchar(254) not null primary key,
			password   varchar(254) not null,
			isadmin	   boolean default false not null)"""
		execute(sql)
	}

	def addUser(userEntry: UserEntry, password: String): Future[Unit] = withConnection{ conn =>
		val ps = conn.prepareStatement("insert into users (mail,password,isadmin) values(?,?,?)")

		ps.setString(1, userEntry.id.email)
		ps.setString(2, hash(userEntry.id.email, password))
		ps.setBoolean(3, userEntry.isAdmin)
		ps.execute()
	}

	def userExists(uid: UserId): Future[Boolean] = withConnection { conn =>
		val ps = conn.prepareStatement("select 1 from users where mail = ?")
		ps.setString(1, uid.email)
		ps.executeQuery().next()
	}

	def authenticateUser(uid: UserId, password: String): Future[UserEntry] = withConnection: conn =>
		val ps = conn.prepareStatement("select isadmin from users where mail = ? and password = ?")
		ps.setString(1, uid.email)
		ps.setString(2, hash(uid.email, password))

		val rs = ps.executeQuery()
		if  rs.next() then
			UserEntry(uid, rs.getBoolean("isAdmin"))
		else
			throw AuthenticationFailedException


	def updateUser(oldUid: UserId, ue: UserEntry, newPass: String): Future[Unit] =
		withConnection: conn =>
			val ps = conn.prepareStatement("update users set isadmin=?, password=? where mail=?")
			ps.setBoolean(1, ue.isAdmin)
			ps.setString(2, hash(ue.id.email, newPass))
			ps.setString(3, oldUid.email)
			ps.executeUpdate()
		.controlUserUpdate(oldUid)


	def dropUser(uid: UserId): Future[Unit] =
		withConnection: conn =>
			val ps = conn.prepareStatement("delete from users where mail = ?")
			ps.setString(1, uid.email)
			ps.executeUpdate()
		.controlUserUpdate(uid, "deleted")


	def listUsers: Future[Seq[UserEntry]] = withConnection{conn =>
		val st = conn.createStatement
		val rs = st.executeQuery("select mail, isadmin from users")

		val result = Buffer.empty[UserEntry]

		while(rs.next()){
			result += UserEntry(UserId(rs.getString("mail")), rs.getBoolean("isadmin"))
		}
		result.toVector
	}

	def userIsAdmin(uid: UserId): Future[Boolean] = withConnection: conn =>
		val ps = conn.prepareStatement("select 1 from users where mail = ? and isadmin")
		ps.setString(1, uid.email)
		ps.executeQuery().next()


	def setAdminRights(uid: UserId, isAdmin: Boolean): Future[Unit] =
		withConnection: conn =>
			val ps = conn.prepareStatement("update users set isadmin = ? where mail = ?")
			ps.setBoolean(1, isAdmin)
			ps.setString(2, uid.email)
			ps.executeUpdate()
		.controlUserUpdate(uid)

	extension(f: Future[Int])
		private def controlUserUpdate(user: UserId, op: String = "updated"): Future[Unit] = f.flatMap: nUpdated =>
			if nUpdated == 1 then Future.successful(())
			else if nUpdated == 0 then Future.failed(cpauthException(s"User ${user.email} not found"))
			else Future.failed(cpauthException(s"Unexpectedly $op $nUpdated users instead of 1"))

end JdbcUsers
